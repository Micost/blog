---
description: Design and Analysis of Algorithms
---

# 3 MIT 6.046J

**Algorithmic Paradigms**

* Divide and conquer
* Dynamic programming
* Greedy algorithms
* Graph algorithms
* NP-completeness

**Divide and conquer**

This technique involves <mark style="color:red;">breaking a problem down into smaller sub-problems</mark>, <mark style="color:red;">solving each sub-problem recursively</mark>, and then combining the solutions to the sub-problems to obtain a solution to the original problem. For instance, <mark style="color:red;">binary\_search, merge sort, quicksort</mark> and <mark style="color:red;">Karatsuba algorithm</mark> for multiplying large integers.

**Dynamic programming**

This technique involves solving a problem by breaking it down into smaller sub-problems and then solving each sub-problem only once and storing the solution for future use. <mark style="color:red;">This can be more efficient than solving the sub-problems repeatedly.</mark>

**Greedy algorithms**

This technique involves <mark style="color:red;">making locally optimal choices at each step</mark> in the hope of finding a global optimum. For example, like <mark style="color:red;">Huffman coding, Prim's algorithm for minimum spanning trees</mark>, and <mark style="color:red;">Dijkstra's algorithm for shortest paths in a graph</mark>.

**Graph algorithms**

This topic covers a range of algorithms for working with graphs, including algorithms for <mark style="color:red;">finding shortest paths</mark>, <mark style="color:red;">minimum spanning trees</mark>, and <mark style="color:red;">maximum flows</mark>. For exmaple, like <mark style="color:red;">Dijkstra's algorithm, Prim's algorithm, Kruskal's algorithm for minimum spanning trees</mark>, and the <mark style="color:red;">Ford-Fulkerson algorithm for maximum flow</mark>.

**NP-completeness**

This topic deals with the complexity of computational problems and the class of problems that are considered "intractable" (i.e., <mark style="color:red;">cannot be solved efficiently using current algorithms</mark>). For example, like the <mark style="color:red;">traveling salesman problem</mark> and the <mark style="color:red;">Boolean satisfiability problem</mark>.









