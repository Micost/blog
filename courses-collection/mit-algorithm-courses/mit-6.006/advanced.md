# Advanced

**Time complexity**

{% hint style="info" %}
In computer science, computational complexity is the study of how efficiently a problem can be solved algorithmically.
{% endhint %}

* **O(1)**: <mark style="color:red;">constant time</mark>, meaning that the time taken by the algorithm does not depend on the size of the input
* **O(log n)**: <mark style="color:red;">logarithmic time</mark>, meaning that the time taken by the algorithm grows logarithmically with the size of the input
* **O(n)**: <mark style="color:red;">linear time</mark>, meaning that the time taken by the algorithm grows linearly with the size of the input
* **O(n log n)**: <mark style="color:red;">quasilinear time</mark>, meaning that the time taken by the algorithm grows near-linearly with the size of the input
* **O(n^2)**: quadratic time, meaning that the time taken by the algorithm grows quadratically with the size of the input
* **O(2^n)**: <mark style="color:red;">exponential time</mark>, meaning that the time taken by the algorithm grows exponentially with the size of the input

In general, we aim to design algorithms with the smallest possible time and space complexity, as this will allow us to solve larger and more complex problems efficiently.

**Topics in algorithms research**

1. **Machine learning algorithms**: Machine learning is a rapidly growing field that involves training computers to learn patterns in data and make predictions or decisions based on that data. There are a variety of algorithms used in machine learning, including <mark style="color:red;">deep learning algorithms</mark>, <mark style="color:red;">reinforcement learning algorithms</mark>, and <mark style="color:red;">decision tree algorithms</mark>.
2. **Graph algorithms**: Graph algorithms are used to <mark style="color:red;">analyze relationships</mark> between entities in a network. Some common graph algorithms include <mark style="color:red;">Dijkstra's shortest path algorithm</mark>, the <mark style="color:red;">Bellman-Ford algorithm</mark>, and the <mark style="color:red;">Floyd-Warshall algorithm.</mark>
3. **Approximation algorithms**: Approximation algorithms are used to <mark style="color:red;">find near-optimal solutions to problems</mark> that are computationally difficult to solve exactly. These algorithms <mark style="color:red;">trade off optimality for efficiency</mark>, providing solutions that are close to optimal while running in polynomial time.
4. **Online algorithms**: Online algorithms are used in situations where the input data is received in a stream or online fashion, and <mark style="color:red;">decisions must be made in real-time without knowledge of future input</mark>. Examples of online algorithms include the paging algorithm and the <mark style="color:red;">k-server algorithm.</mark>
5. **Randomized algorithms**: Randomized algorithms use <mark style="color:red;">randomness as a tool to solve problems more efficiently or accurately than deterministic algorithms.</mark> Examples of randomized algorithms include <mark style="color:red;">the randomized quicksort algorithm</mark> and the <mark style="color:red;">Monte Carlo algorithm</mark>.
6. **Parallel algorithms**: Parallel algorithms are designed to take advantage of <mark style="color:red;">parallel computing architectures</mark>, allowing multiple computations to be performed simultaneously. Some common parallel algorithms include the parallel merge sort algorithm and the parallel matrix multiplication algorithm.

